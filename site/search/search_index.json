{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hello!","text":"<p>You've reached my blog. Head over to my blog posts</p>"},{"location":"blog/","title":"All posts","text":"<p>I post random things that are tangentially related to data structures and algorithms, deep learning, and other machine learning related topics.</p>"},{"location":"blog/2024/01/04/manacher-algo/","title":"Manacher's Algorithm","text":"<p>Super annoying algorithm, but it has uses in bioinfomatics. </p> <p>Here's the task: Given a string\u00a0<code>s</code>, return\u00a0the longest palindromic substring \u00a0in\u00a0<code>s</code>.</p> <p>Example inputs and outputs:</p> <p>Input: s = \"babad\" Output: \"bab\" Explanation: \"aba\" is also a valid answer.</p> <p>Input: s = \"cbbd\" Output: \"bb\"</p> <p>To build some intuition for how this algorithm works, let's see an example of a brute force implementation. In this implementation, given a string <code>_str</code>, we want to see for any <code>i</code>, what is the maximum length of a palindrome centred around the character <code>_str[i]</code>. Something simple would be something like this: </p> <pre><code>def manacher_brute_force(_str: str) -&gt; list:\n  _str_len = len(_str)\n  out = [0 for _ in range(_str_len + 2)]\n  # make sure first and last chars are different and do not\n  #\u00a0happen in _str itself\n  _str = f\"${_str}^\"\n\n  for i in range(1, _str_len + 1):\n\n    while _str[i - out[i]] == _str[i + out[i]]:\n      out[i] += 1\n  return out\n\nif __name__ == \"__main__\":\n  print(manacher_brute_force(\"abbcbba\"))\n</code></pre> <p>the output will be something like <code>[0, 1, 1, 1, 4, 1, 1, 1, 0]</code></p> <p>But in this approach, when we sweep from left to right, we are not using the work we have already done to the left of <code>i</code>. This is where Manacher comes in. </p>","tags":["algorithms"]},{"location":"blog/2024/01/04/manacher-algo/#what-dont-we-have-to-search","title":"What don't we have to search?","text":"<p>We can exploit the nature of a palindrome - assume we have a palindrome of length <code>l</code> centred around index <code>i</code>, and say we take 2 indexes <code>i'</code> and <code>i''</code> that are distance <code>d</code> left and right to <code>i</code> respectively s.t. <code>d &lt; l</code>, then we basically know that any palindrome that is centred around <code>i'</code> will also likely be centred around <code>i''</code>!</p> <p>From this simple observation, we can already amend the inner <code>while</code> loop so that we are not searching all of the characters to the left and right of a particular index <code>i''</code> of an index that is to the right of an index <code>i</code> we have already done work for.  </p> <p>The rest of the complexity comes from the need to handle the case where the borders of the inner palindrome reaches the border of the outer palindrome. All you have to do there is make sure you always check whenever you go beyond the borders of the longest current palindrome. </p> <pre><code>def manacher_odd(_str: str) -&gt; list:\n    _str_len = len(_str)\n    out = [0 for _ in range(_str_len + 2)]\n    # make sure first and last chars are different and do not\n    #\u00a0happen in _str itself\n    _str = f\"${_str}^\"\n    l, r = 1, 1\n    for i in range(1, _str_len + 1):\n        dist_to_border = r - i\n        inner_palindrome_len = min(dist_to_border, out[l + dist_to_border])\n        out[i] = max(0, inner_palindrome_len)\n        while _str[i - out[i]] == _str[i + out[i]]:\n          out[i] += 1\n        if i + out[i] &gt; r:\n            l = i - out[i]\n            r = i + out[i]\n    return out\n</code></pre> <p>Code is a translation of the cpp code here</p> <p>NOTE:</p> <p>The above algorithm is only for odd length. In practice, you can make any string odd length by doing something like </p> <pre><code>_str = \"\u00a3\".join(_str)\n_str = f\"#{_str}^\"\n</code></pre> <p>the <code>.join</code> adds <code>n-1</code> characters to the string, so the total number of characters will be odd, since <code>even + odd = odd</code></p>","tags":["algorithms"]},{"location":"blog/2024/01/04/manacher-algo/#where-does-the-time-saving-come-from-that-makes-it-linear","title":"Where does the time saving come from that makes it linear?","text":"<p>In the brute force method, consider the number of times a character at index <code>i</code> is compared to some other character. You will quickly realise it is <code>O(n)</code>, and that is where the overall \\(O(n^2)\\) complexity for the brute force method comes from. </p> <p>But with Manacher's algorithm, the while loop is no longer independent of the outer for loop. The outer loop is keeping track of the <code>centre</code> of palindromes and is always increasing. We only do additional comparison operations when <code>r</code> variable (i.e. the rightmost boundary, the <code>centre + radius</code> value) increases - and this quantity never decreases in value! Therefore, the total number of operations in the outer and in the inner loop adds to <code>n</code>. </p>","tags":["algorithms"]},{"location":"blog/2024/01/04/manacher-algo/#final","title":"Final:","text":"<pre><code>def manacher(s: str) -&gt; str:\n        if len(s) &lt;= 1:\n            return s\n\n        s = f\"#{'#'.join(s)}#\"\n        s_len = len(s)\n        out = [0 for _ in range(s_len)]\n        max_radius = 1\n        max_str = s[1]\n\n        l, r = 1, 1\n        for i in range(1, s_len - 1):\n            dist_to_edge = r - i\n            allowable_dist = min(dist_to_edge, out[l + dist_to_edge])\n            out[i] = max(0, allowable_dist)\n            while i - out[i]&gt;= 0 and i + out[i] &lt; s_len and s[i - out[i]] == s[i + out[i]]:\n                out[i] += 1\n            if i + out[i] &gt; r:\n                r = i + out[i]\n                l = i - out[i]\n            if out[i] &gt; max_radius:\n                max_radius = out[i]\n                max_str = s[l + 1 : r].replace(\"#\", \"\") # if you want s[l: r + 1] you need to offset in the while loop like so: \n                # while i - out[i] - 1&gt;= 0 and i + out[i] + 1 &lt; s_len and s[i - out[i] - 1] == s[i + out[i] + 1]\n        return max_str\n</code></pre> <p>or if you want to use the original <code>manacher_odd</code> kind of notation:</p> <pre><code>    def manacher(s: str) -&gt; str:\n        if len(s) &lt;= 1:\n            return s\n\n        s = f\"\u00a3#{'#'.join(s)}#^\"\n        s_len = len(s)\n        out = [0 for _ in range(s_len)]\n        max_radius = 1\n        max_str = s[1]\n\n        l, r = 1, 1\n        for i in range(1, s_len - 1):\n            dist_to_edge = r - i\n            allowable_dist = min(dist_to_edge, out[l + dist_to_edge])\n            out[i] = max(0, allowable_dist)\n            while s[i - out[i]] == s[i + out[i]]:\n                out[i] += 1\n            if i + out[i] &gt; r:\n                r = i + out[i]\n                l = i - out[i]\n            if out[i] &gt; max_radius:\n                max_radius = out[i]\n                max_str = s[l + 1 : r].replace(\"#\", \"\")\n        return max_str\n</code></pre>","tags":["algorithms"]},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/category/algorithms/","title":"algorithms","text":""}]}